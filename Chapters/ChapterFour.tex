\chapter{Resultados}
\label{chap:result}
A elaboração de cronogramas, e a organização das atividades em pacotes com metas de curto médio e longo prazo contribuiu para que o andamento do projeto ocorresse de forma satisfatória. Os prazos foram mudados  durante o projeto e os atrasos gerados por problemas inesperados conseguiram ser compensados com uma mudança na forma de gerir os integrantes e a inserção de tarefas em paralelo, sendo elas individuais e em subgrupos


%--------- NEW SECTION ----------------------
\section{Testes unitários}
\label{sec:testu}
Consistem nos testes individuais das ferramentas, tem suma importância para atestar se as ferramentas pré determinadas funcionam de acordo com o esperado.


\subsection{Configuração dos servomotores}
Os primeiros testes realizados no início do desenvolvimento do robô foram a configuração dos servomotores, etapa essencial para a definição de como os motores deveriam trabalhar em conjunto. A configuração se deu utilizando diversos softwares, e após as configurações realizadas, os motores eram analisados para validar se a configuração fora realizada de maneira correta.

\subsubsection{Utilização do software Mixcell}
O software Mixcell, desenvolvido por integrantes do grupo Mandruvah, disponível para utilização gratuita na Ros Wiki, possui a funcionalidade de realizar a configuração de parâmetros em motores Dynamixel de diversos modelos, tais como ID dos motores, modos de operação, baudrate para comunicação serial. O software foi utilizado em toda as etapas de testes dos motores, sendo fundamental para determinar o funcionamento de cada um dos motores e para o desenvolvimento e montagem do robô. 

FALTA IMAGEM
\subsubsection{Modos Mestre/Escravo}
Durante os testes em modo Mestre/Escravo dos motores Dynamixel, foi observado que mesmo quando dois motores são configurados para trabalharem como mestre/escravo via software, é necessário que se haja a utilização do cabo de sincronização entre os dois motores. Foi constatado durante os testes que o cabo de sincronização transmite a informação de carga para que haja a compensação entre os motores quando trabalham em conjunto. 

\subsubsection{ ID, Baud rate e Modos de operação}
Durante toda a fase de testes foram observados parâmetros extremamente importantes para definição e funcionamento dos motores Dynamixel. Os IDs dos motores definem basicamente a sua identificação para as configurações de juntas, associando assim os motores as suas respectivas juntas. 
O baud rate é a taxa de transmissão de dados em bits por segundo entre o computador e os motores. Percebeu-se que durante os testes, para um número grande de motores trabalhando em conjunto, era necessário um valor de baudrate mais elevado para que todos os motores fossem encontrados. 
Os modos de operação dos motores são parâmetros que definem como os mesmos vão se comportar durante a operação, sendo eles os modos junta e roda. No primeiro modo é necessário estabelecer um limite máximo e mínimo para o giro dos motores, além da definição de qual  motor será o mestre ou o escravo durante a operação (caso haja mais de um motor na junta), enquanto que no modo roda o motor irá girar livremente, mudando somente o sentido de giro. 

\subsection{Controle dos servomotores utilizando a biblioteca dynamixel driver}
A biblioteca dynamixel driver foi a utilizada nesse projeto e tal, para fazer a configurações , criar os controladores, possibilitar a integração do motor no sistema ros. Essa biblioteca foi descontinuada na versão utilizada no projeto, o que fez com se mostrassem necessários testes extras. Este teste foi realizado por TALTALTALTAL, durante a fase inicial do projeto que se deu entre tal DIA até TAL DIA.
\subsubsection{Teste dos controladores de posição}
Foi realizado o teste dos motores de posição para verificar o comportamento dos mesmos. Nas juntas dos braços do robô foi utilizado o modo de controlador de posição, isto é: o motor recebe um comando de posição, que no caso é de 0 a 2PI radianos e assim é possível controlar para  onde o braço irá se mover. 
O controlador recebe um arquivo de configuração das juntas, especificando os ids e assim pode-se controlar cada um individualmente. Foi realizado o teste em todas as juntas de posição do ELIR.

\subsubsection{Teste dos Controladores de velocidade}
Os controladores individuais de velocidade tem a função de controlar a velocidade do motor, sem controlar a posição. O motor irá rodar livremente com uma velocidade determinada até que receba um comando para parar. Este controlador foi usado nas rodas das garras que possuem a finalidade de fazer o robô andar sobre a linha. Cada roda fora testada individualmente.

\subsubsection{Teste Controladorcontrolador de trajetoria}
O controlador meta controller realiza o controle do posicionamento da junta como um todo. Neste controlador é possível controlar diversas juntas diferentes do robô por meio de uma única mensagem no ROS, contendo o nome das juntas que deverão ser controladas, as posições desejadas, tempos de execução, velocidades e esforço. Esse controlador se mostrou extremamente importante e eficiente pela sua capacidade de agrupar diversas juntas em um único comando de movimento. 

\subsubsection{Compatibilidade com diferentes protocolos de comunicação}
Há uma limitação na biblioteca dynamixel driver, esta funciona somente para motores com firmware versão 1.0 devido a sua descontinuação. Foi testado para todas as versões contidas nos motores que possuíam e não houveram falhas em encontrar nenhum motor na biblioteca. Entretanto, caso houvesse necessidade de atualizar para versão v2.0, no qual possui uma taxa de baud rate maior e protocolo de comunicação melhorado, haveria a necessidade de parar com o uso a dynamixel driver e utilizar a biblioteca oficial da fabricante, a dynamixel workbench.

\subsection{Controle dos servomotores utilizando a biblioteca dynamixel workbench}
A biblioteca do ROS dynamixel workbench  é outro driver para comunicação com os servomotores, recebe suporte e atualizações diretamente da ROBOTIS, sendo o driver de controle padrão do ROS para versões superiores a Kinetc. Considerou se utilizar essa ferramenta devido aos problemas de comunicação apresentados pelos motores. Ela oferece suporte para o protocolo de comunicação na versão 2.0, que suporta uma maior baudrate e muda a estrutura de comunicação.

\subsubsection{Controladores de posição}
A biblioteca oferece a opção de criar controladores de posição individuais para cada motor, sem especificar o ID. Não possibilitando uma criação controlador mestre-escravo para as juntas do robô que são atuadas por 2 motores e também a opção de selecionar quais motores da rede seriam transformados em controladores de posição, o arquivo que instancia os controladores só recebe um alcance de IDs que deve buscar na rede, transformando todos os motores nesse alcance em controladores de posição individuais.

\subsubsection{Controladores de velocidade}
Os controladores de velocidade só recebem o ID de dois motores, assim não apresentando um uso trivial, já que o robô necessita de 5 controladores de velocidade diferentes. Foi encontrado um arquivo customizado no repositório da biblioteca, mas mesmo assim não pode ser utilizado em conjunto com controladores de posição.
\subsubsection{Controladores de trajetória}
Os controladores de trajetória esperados para compatibilização com o planejamento de movimento são os padrões oferecidos pela biblioteca embutida do ROS, o \verb|ros_control|. Porém a biblioteca não oferece um driver que instancie esses controladores de trajetória, assim não possibilitando a integração dela com o planejamento de movimento.

\subsubsection{Comunicação em rede}
Em comparação com a biblioteca antiga, a comunicação em rede dos servomotores utilizando essa biblioteca é levemente superior. Quando a comunicação apresentava problemas ,essa biblioteca se mostrou mais eficiente para encontrar os motores conectados na rede porém não possibilita o funcionamento completo, assim não se mostrando uma opção para resolução dos problemas de comunicação com os motores.
Os motores com protocolo de comunicação 2.0 podem ser utilizados em conjunto com os 1.0 nessa biblioteca, porém não se tiverem o mesmo ID.

\subsection{Compatibilidade do Elir Robot com o MoveIt!}
O MoveIt! fornece uma ferramenta de configuração denominada Setup Assistant, que gera a maior parte dos arquivos necessários para a compatibilização.

IMAGEM

\subsubsection{Teste de Estado de Colisão}
Durante a configuração dos Setup Assistant , o robô apresentava um erro informando que o seu modelo estava em estado de colisão, o que significa que as partes do seu modelo estavam posicionadas erradas e estariam sempre colidindo.
Foi feito um teste removendo todas as partes do robô do arquivo de configuração e checando se a indicação de erro sumia. Com as tentativas se concluiu o problema era o modelo 3D utilizado nas rodas do robô, que gerava a colisão quando se utilizava ele mais de uma vez, a resolução foi a criação de um novo modelo 3D para as rodas, após a substituição o erro sumiu.

\subsubsection{Teste de Definição da corrente-cinemática e end-effector}
No estudo de cinemática inversa na robótica, corrente cinemática é o nome dado para o conjunto de links e juntas que se vai calcular o movimento, onde o começo dessa corrente é a referência para o cálculo da cinemática e o final da corrente é o end-effector.  No caso do Elir, é necessário se definir duas correntes cinemáticas, já que são dois braços. Com a corrente cinemática definida corretamente ,o MoveIt! consegue enviar o comando para movimentar as juntas da corrente simultâneamente.
Ao definir o grupo de controle no Setup Assistant, o usuário escolhe as juntas que irão fazer parte desse grupo, e a corrente cinemática é gerada automaticamente. Foram feitos teste considerando como parte da corrente somente as duas juntas do braço, porém ao analisar outros robôs que já haviam sido configurados, notou-se que sempre se levava em consideração a junta da base do robô para definição do grupo, onde a junta da base é a junta que prende o robô no mundo.


\subsection{Robô de testes Davictory}
Como o Setup-Assistant oferece diversas opções de configuração, optou-se por desenvolver um modelo de robô mais simples que o ELIR, de forma que se pudessem testar os conceitos, e compreender melhor a relação entre as configurações do modelo e os resultados esperados para movimento.
Esse teste foi executado pelos membros Cleber Couto e Davi Oliveira, no período de: onde esse modelo foi inteiramente escrito pela equipe, tomando como base boas práticas observadas em robôs já compatibilizados código URDF. O Davictory foi construído como mostra a imagem[x]:

IMAGEM

Antes de realizar qualquer modificação na modelagem do robô ELIR primeiramente essa modificação foi feita Davictory, assim foram prevenidos quaisquer mudanças desnecessárias e otimizado o tempo devido que o robô customizado ser mais simples. Todos os testes com o planejamento de movimento foram validados também nele.


\subsubsection{Teste com diferentes plugins de cinematica}
Para configurar o pacote do MoveIT! de qualquer modelo de robô, é necessário definir qual plugin de solução da cinemática irá seguir. Como existem variados tipos de robôs com finalidades e conjuntos de movimentos diferentes essa escolha deve ser feita de forma precisa para que o robô em questão realize o movimento de forma eficiente.
Durante a escolha para a cinemática do ELIR foi percebido que nenhum plugin se encaixava nas descrições devido ao número reduzido de graus de liberdades (o ELIR possui 2 graus de liberdades e os plugins necessitam de no mínimo 3). A fim de achar uma solução que atendesse ao funcionamento do ELIR, foram testados no Davictory todos os plugins de cinemática contidos no site oficial do MoveIT!. Nenhum plugin obteve sucesso em resolver a cinemática inversa.


\subsection{Cálculo da cinemática inversa}
Após a falha busca por um plugin que realizasse a cinemática inversa do ELIR, foi necessário calcular a cinemática inversa em um serviço por meio de equações. Partindo do pressuposto que o end-effector se encontra no 0 no plano cartesiano, é inserido as coordenadas para onde deve-se ir por meio das equações retorna-se os valores que cada junta deve realizar, a equação em questão é mostrada abaixo:

IMAGEM

\subsection{Power Management}
A placa de power management é responsável pelo gerenciamento de energia do robô, ela distribui de forma separada a potência para cada parte elétrica ou eletrônica, e pela sua capacidade de monitoramento, pode identificar e atuar sob algum erro na alimentação. O design e fabricação da placa foram realizados por Matheus Menezes e Branilson Luiz, tendo sua utilização adaptada para o ELIR. Diversos testes foram feitos para garantir que a mesma estivesse trabalhando de maneira correta.

\subsubsection{Gravação  e validação de Firmware na placa de Power Management}
A gravação do firmware na placa de Power Management só foi realizada devido a utilização de um botão para conectar dois pinos específicos da placa (-VIN e S2) para que o microcontrolador fosse alimentado, e a conexão da placa em uma porta USB de um computador. 
Para que fosse possível estabelecer a comunicação entre o computador e a placa, foi necessário configurar as permissões necessárias no Ubuntu. Durante a gravação do firmware fora utilizada uma extensão do VSCode, o PlatformIO, específica para programação com microcontroladores, para realização de debug e gravação do firmware na placa. 
Durante o processo de gravação foi necessário manter o botão pressionado. Após a gravação do firmware na placa, o seu funcionamento fora validado através do uso dos serviços e mensagens gerados no ambiente ROS, uma vez que as informações de níveis de corrente e tensão das portas da placa eram publicados nos tópicos específicos. O teste foi coordenado por Ícaro Nascimento no dia 1 de agosto de 2018.

\subsection{Acesso remoto a nuc}
O robô deve ser acessado remotamente para que se inicie a missão, esse acesso é feito através do protocolo SSH.
A comunicação no SSH funciona como servidor-cliente, onde a NUC é definida como o servidor, de forma a ser acessada remotamente. Por ser necessário o IP do servidor para realizar a conexão e durante os testes com o robô em linha não é possível consultar endereço de IP diretamente, foi criada uma rede Wi-Fi por um roteador móvel, onde o IP da NUC era fixo.



%--------- NEW SECTION ----------------------
\section{Testes integrados}
\label{sec:testi}
asdfadsfsdfs

%--------- NEW SECTION ----------------------
\section{Avaliação da prontidão tecnológica}
\label{sec:trl}
asdfadsfsdfs

%--------- NEW SECTION ----------------------
\section{Trabalhos futuros}
\label{sec:trabfut}
A implementação de um robô para inspeção de linha, faz possível que sejam implementadas diferentes tipos de tecnologias, já que a sua estrutura pode ser projetada para receber uma série de implementações. Um drone por exemplo, consegue realizar uma manutenção visual efetiva, sem muito gasto energético, mas seu tamanho reduzido faz com que algumas tecnologias não consigam ser implantadas.

Os resultados dos testes possibilitam o início de novos estudos e mostra comportamentos específicos de cada componente que tem que ser levados em consideração. Os servomotores apresentaram um melhor desempenho quando alimentados com 14.4V, conseguindo realizar movimentos que necessitavam de mais torque de forma efetiva, enquanto com 12V o movimento não acontecia de forma consistente. Hoje a ROBOTIS desenvolve modelos de servomotores que possuem um torque máximo muito elevado, assim se torna viável a troca dos motores nas juntas que realizam mais esforço, assim como o estudo para aumento da tensão de alimentação ou um estudo dirigido para encontrar o melhor valor da curva torque e tensão de alimentação.

O MoveIt! possibilita a integração com ferramentas de visualização, assim tornando viável a futura implementação de um sistema de controle baseado em percepção 3D e odometria visual. O uso de algoritmos de detecção de obstáculos precisos, torna possível a ultrapassagem automática de obstáculos, sendo possível inserir o obstáculo no ambiente do robô e realizar o desvio automaticamente.






